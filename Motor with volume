#include "DualMC33926MotorShield.h"
  #define SPEED 160
  #define MINSPEED 160
  #define MAXSPEED 400
//  #define MAXPOS1 1000
//  #define MAXPOS2 1001
//  #define MAXPOS3 1002
  #define MINPOS1 293
  #define MINPOS2 294
  #define MINPOS3 295
  #define VOL04   833
  #define VOL03   708
  #define VOL02   573
  #define VOL01   450
  #define VOL005  372
  #define VOL002  325
  
  DualMC33926MotorShield md;
  unsigned long time1;
  int motorSpeed = SPEED;
  unsigned long last = 0;
  unsigned long diff = 0;
  const int analogPin = 2;     // potentiometer wiper (middle terminal) connected to analog pin 3
  const int toggleStop = 5;
  const int inSpeedPin = 6;
  const int reSpeedPin = 3;
  const int pushPullPin = 11;
  int val = 0;           // variable to store the value read
  int prePos = 0;
  int count = 0;
  int chosenVolume = VOL04;
  int MAXPOS1 = chosenVolume-1;
  int MAXPOS2 = chosenVolume;
  int MAXPOS3 = chosenVolume+1;
  int aMax[3] = {MAXPOS1,MAXPOS2,MAXPOS3};
  int aMin[3] = {MINPOS1,MINPOS2,MINPOS3};
  int maxFound = MAXPOS2;
  int minFound = MINPOS2;
  int first1 = 0;
  int togCounter = 0;
  int inCounter = 0;
  int reCounter = 0;
  int preSpeed;
  int preCount;
  int pushPullCounter = 0;
  int preSpeed2 = 0;
  
  void stopIfFault()
  {
    if (md.getFault())
    {
      Serial.println("fault");
      while(1);
    }
  }
  
  void speedInit()
  {
      if (val <= minFound)
      {
        motorSpeed = 0-SPEED; // currently below or at min, need to go out cross min and stop at max => want to skip the first = set count to 1
        count = 1;            
      }
      else if  (val >= maxFound)
      {
        motorSpeed = SPEED;  //  currently above or at max, need to go in cross max and stop at min, but meet max first => want to skip the first = set count to 0
        count = 0;
      }
      else if (val< maxFound && val > minFound)
      {
        motorSpeed = SPEED; // now moving into,will meet min first and need to reverse, count must = 0 be considered at min
        count = 0;
      }
      first1++;
      Serial.println("HAHAH");
      Serial.print("first SPEED is: ");
      Serial.println(motorSpeed);
      Serial.print("position is: ");
      Serial.println(val);
  }
  
  void maxMin()
  {
      for(int i=0 ; i<3; i++)
    {
      if(val == aMax[i])
      {
        maxFound = aMax[i];
      }
      else if (val == aMin[i])
      {
        minFound = aMin[i];
      }
    }
  }
  
  void buttonCheck1() //when press should stop the syringe and maintain all old data, need another press to resume
  {
  
    if  ( (digitalRead(toggleStop) == HIGH) && (togCounter == 0) ) // since initialize counter to 0, make sure that button signal is off at beginning else it will stop immediately
    {
      preSpeed = motorSpeed;
      preCount = count;
      motorSpeed = 0;
      count = 3; // not 0 or 1 so that all data kept same
      togCounter++;
      Serial.print("save speed is: ");
      Serial.println(preSpeed);
      Serial.print("save count is: ");
      Serial.println(preCount);    
      Serial.println("currently stop");
      Serial.print("pos stop is: ");
      Serial.println(val);
      
    }
    else if( (digitalRead(toggleStop) == HIGH) && (togCounter == 1)) //toggle on
    {
      if ( (digitalRead(inSpeedPin) == LOW) && (inCounter == 0))
      {
        preSpeed = preSpeed + 10;
        if(preSpeed >= MAXSPEED)
        {
          preSpeed = preSpeed-10;
          Serial.println("max speed reached, stop ");
        }
            Serial.print("in speed modified is ");
      Serial.println(preSpeed); 
        inCounter++;
      }
      else if((digitalRead(inSpeedPin) == HIGH) && (inCounter == 1))
      {
        inCounter = 0;
      }
  
      if ( (digitalRead(reSpeedPin) == LOW) && (reCounter == 0))
      {
        preSpeed = preSpeed - 10;
        if(preSpeed <= MINSPEED)
        {
          preSpeed = preSpeed+10;
          Serial.println("min speed reached, stop ");
        }
            Serial.print("re speed modified is ");
      Serial.println(preSpeed); 
        reCounter++;
      }
      else if((digitalRead(reSpeedPin) == HIGH) && (reCounter == 1))
      {
        reCounter = 0;
      }  
    }
  
    
    else if ( (digitalRead(toggleStop) == LOW) && (togCounter == 1)) // toggle off
    {
      motorSpeed = preSpeed;
      count      = preCount;
      togCounter    = 0;
  
      Serial.print("resume speed is: ");
      Serial.println(motorSpeed);
      Serial.print("resume count is: ");
      Serial.println(count);
      Serial.println("resuming in 1 second");
      delay(1000);
    }
    else
    {   
    }  
  }
  //1st cases: max <----- 1023: want to keep it going, if at max, if speed > 0 then do nothing, count must = 1
  //2nd cases: min <----- max : want to reverse it   , if at min, if speed > 0 then reverse, count must = 0
  //3rd cases: 0   -----> min : want to keep it going, if at min, if speed < 0 then do nothing, count must = 0
  //4th cases: min -----> max : want to reverse it   , if at max, if speed < 0 then reverse , count must = 1
  //5th cases: at min         : want to set count to 0 so that below function will turn it into 1 and not change negative speed
  //6th cases: at max         : want to set count to 1 so that below function will turn it into 0 and not change positive speed
  
  void setup()
  {
    Serial.begin(9600);
    Serial.println("Dual MC33926 Motor Shield");
    pinMode(toggleStop, INPUT);
    pinMode(inSpeedPin, INPUT);
    pinMode(reSpeedPin, INPUT);
    pinMode(pushPullPin, INPUT);
    md.init();
  }
  
  void loop()
  {
    val = analogRead(analogPin);    // read the input pin, need to be before init else init has no val data
  
      if (first1 == 0)
    {
      speedInit();
    }
    maxMin();
  //******************* Main operation ************************
  //**OPERATION is first syringe needs to travel to min point and wait there, switch at min must be 0
  //**When the switch on, syringe travel out, pushPullpin is now high
  //**High pin will be kept until reach max point, high will keep syringe stay at max
  //**Turn low to travel back to 0ml position
        //********************************************************8
  if ((val ==  maxFound) && (count == 1))
     {
            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      if  ( (digitalRead(pushPullPin) == LOW) && (pushPullCounter == 1) )
      {
             if (preSpeed2 < 0)
        {
          motorSpeed = preSpeed2;
          motorSpeed = motorSpeed + 2*abs(motorSpeed);
          pushPullCounter = 0;
          preSpeed2 = 0;    
          count = 0;          
          Serial.println("returning in 1sec from Max");         
        } 
      }
      else if ( (digitalRead(pushPullPin) == HIGH) && (pushPullCounter == 1) )
      {
        preSpeed2 = preSpeed2 + motorSpeed;
        motorSpeed = 0;
      }
          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^6
     }

     //***********************************************
     else if ( (val == minFound) && (count == 0))
     {
      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     if  ( (digitalRead(pushPullPin) == HIGH) && (pushPullCounter == 0) )
      {
             if (preSpeed2 > 0)
        {
          motorSpeed = preSpeed2;
          motorSpeed = 0- motorSpeed; 
          pushPullCounter++;
          count = 1;
          preSpeed2 = 0;
          Serial.println("returning in 1sec from Min");
        }
      }
      else if ( (digitalRead(pushPullPin) == LOW) && (pushPullCounter == 0) )
      {
        preSpeed2 = motorSpeed + preSpeed2;
        motorSpeed = 0;              
      }    
       //^^^^^^^^^^^^^^^^^
     }
    //******************************************8
    buttonCheck1();
    md.setM1Speed(motorSpeed);
  
}
