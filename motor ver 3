#include "DualMC33926MotorShield.h"
#define SPEED 160
#define MINSPEED 160
#define MAXSPEED 400
#define MAXPOS1 1000
#define MAXPOS2 1001
#define MAXPOS3 1002
#define MINPOS1 293
#define MINPOS2 294
#define MINPOS3 295
DualMC33926MotorShield md;
unsigned long time1;
int motorSpeed = SPEED;
unsigned long last = 0;
unsigned long diff = 0;
const int analogPin = 2;     // potentiometer wiper (middle terminal) connected to analog pin 3
const int toggleStop = 5;
const int inSpeedPin = 6;
const int reSpeedPin = 3;
int val = 0;           // variable to store the value read
int prePos = 0;
int count = 0;
int aMax[3] = {MAXPOS1,MAXPOS2,MAXPOS3};
int aMin[3] = {MINPOS1,MINPOS2,MINPOS3};
int maxFound = MAXPOS2;
int minFound = MINPOS2;
int first1 = 0;
int togCounter = 0;
int inCounter = 0;
int reCounter = 0;
int preSpeed;
int preCount;
void stopIfFault()
{
  if (md.getFault())
  {
    Serial.println("fault");
    while(1);
  }
}

void speedInit()
{
    if (val <= minFound)
    {
      motorSpeed = 0-SPEED; // currently below or at min, need to go out cross min and stop at max => want to skip the first = set count to 1
      count = 1;            
    }
    else if  (val >= maxFound)
    {
      motorSpeed = SPEED;  //  currently above or at max, need to go in cross max and stop at min, but meet max first => want to skip the first = set count to 0
      count = 0;
    }
    else if (val< maxFound && val > minFound)
    {
      motorSpeed = SPEED; // now moving into,will meet min first and need to reverse, count must = 0 be considered at min
      count = 0;
    }
    first1++;
    Serial.println("HAHAH");
    Serial.print("first SPEED is: ");
    Serial.println(motorSpeed);
    Serial.print("position is: ");
    Serial.println(val);
}

void maxMin()
{
    for(int i=0 ; i<3; i++)
  {
    if(val == aMax[i])
    {
      maxFound = aMax[i];
    }
    else if (val == aMin[i])
    {
      minFound = aMin[i];
    }
  }
}

void buttonCheck1() //when press should stop the syringe and maintain all old data, need another press to resume
{

  if  ( (digitalRead(toggleStop) == HIGH) && (togCounter == 0) ) // since initialize counter to 0, make sure that button signal is off at beginning else it will stop immediately
  {
    preSpeed = motorSpeed;
    preCount = count;
    motorSpeed = 0;
    count = 3; // not 0 or 1 so that all data kept same
    togCounter++;
    Serial.print("save speed is: ");
    Serial.println(preSpeed);
    Serial.print("save count is: ");
    Serial.println(preCount);    
    Serial.println("currently stop");
    Serial.print("pos stop is: ");
    Serial.println(val);
    
  }
  else if( (digitalRead(toggleStop) == HIGH) && (togCounter == 1)) //toggle on
  {
    if ( (digitalRead(inSpeedPin) == LOW) && (inCounter == 0))
    {
      preSpeed = preSpeed + 10;
      if(preSpeed >= MAXSPEED)
      {
        preSpeed = preSpeed-10;
        Serial.println("max speed reached, stop ");
      }
          Serial.print("in speed modified is ");
    Serial.println(preSpeed); 
      inCounter++;
    }
    else if((digitalRead(inSpeedPin) == HIGH) && (inCounter == 1))
    {
      inCounter = 0;
    }

    if ( (digitalRead(reSpeedPin) == LOW) && (reCounter == 0))
    {
      preSpeed = preSpeed - 10;
      if(preSpeed <= MINSPEED)
      {
        preSpeed = preSpeed+10;
        Serial.println("min speed reached, stop ");
      }
          Serial.print("re speed modified is ");
    Serial.println(preSpeed); 
      reCounter++;
    }
    else if((digitalRead(reSpeedPin) == HIGH) && (reCounter == 1))
    {
      reCounter = 0;
    }  
  }

  
  else if ( (digitalRead(toggleStop) == LOW) && (togCounter == 1)) // toggle off
  {
    motorSpeed = preSpeed;
    count      = preCount;
    togCounter    = 0;

    Serial.print("resume speed is: ");
    Serial.println(motorSpeed);
    Serial.print("resume count is: ");
    Serial.println(count);
    Serial.println("resuming in 1 second");
    delay(1000);
  }
  else
  {
    
  }
  
}
//1st cases: max <----- 1023: want to keep it going, if at max, if speed > 0 then do nothing, count must = 1
//2nd cases: min <----- max : want to reverse it   , if at min, if speed > 0 then reverse, count must = 0
//3rd cases: 0   -----> min : want to keep it going, if at min, if speed < 0 then do nothing, count must = 0
//4th cases: min -----> max : want to reverse it   , if at max, if speed < 0 then reverse , count must = 1
//5th cases: at min         : want to set count to 0 so that below function will turn it into 1 and not change negative speed
//6th cases: at max         : want to set count to 1 so that below function will turn it into 0 and not change positive speed

void setup()
{
  Serial.begin(9600);
  Serial.println("Dual MC33926 Motor Shield");
  pinMode(toggleStop, INPUT);
  pinMode(inSpeedPin, INPUT);
  pinMode(reSpeedPin, INPUT);
  md.init();
}

void loop()
{
  
  val = analogRead(analogPin);    // read the input pin, need to be before init else init has no val data

    if (first1 == 0)
  {
    speedInit();
  }
  maxMin();
//  if ( ((val ==  aMax[0])|| (val ==  aMax[1]) || (val ==  aMax[2])) && (count == 1))
if ((val ==  maxFound) && (count == 1))
   {

      if (motorSpeed < 0)
      {
        motorSpeed = motorSpeed + 2*abs(motorSpeed);
      } 
//    Serial.print("pos out: ");
//    Serial.println(val);
//    Serial.print("speed is: ");
//    Serial.println(motorSpeed);
    count = 0;
   }
//   else if ( ((val == aMin[0])|| (val == aMin[1]) || (val == aMin[2])) && (count == 0))
   else if ( (val == minFound) && (count == 0))
   {
     if (motorSpeed > 0)
      {
        motorSpeed = 0- motorSpeed; 
      }
//    Serial.print("pos in: ");
//    Serial.println(val);
//    Serial.print("speed is: ");
//    Serial.println(motorSpeed);
    count = 1;
   }

  buttonCheck1();

  md.setM1Speed(motorSpeed);

}
